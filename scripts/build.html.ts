// eslint-disable-next-line @typescript-eslint/no-var-requires
const Inliner = require("inliner");
import { writeFile, readFile } from "fs/promises";
import { resolve as pathResolve, relative as relPath } from "path";
import * as zlib from "zlib";

const UINT16_MAX = 65535;

interface Spec {
  name: string;
  filePath: string;
  method: "plaintext" | "binary";
  append?: string;
  prepend?: string;
  mangle?: (chunk: string) => string;
  inline?: boolean;
  gzip?: boolean;
}

writeChunks(
  [
    {
      filePath: pathResolve(__dirname, "../public/index.html"),
      name: "PAGE_index",
      prepend: "=====(",
      append: ")=====",
      method: "binary",
      inline: true,
      gzip: true,
    },
  ],
  "src/html_ui.h"
);

// TODO: Add favicon
// writeChunks(
//   "public",
//   [
//     {
//       file: "favicon.ico",
//       name: "favicon",
//       method: "binary",
//       gzip: true,
//     },
//   ],
//   "src/html_fixtures.h"
// );

function hexdump(buffer: Buffer) {
  const lines = [];

  for (let i = 0; i < buffer.length; i += 16) {
    const block = buffer.slice(i, i + 16); // cut buffer into blocks of 16
    const hexArray = [];

    for (const value of block) {
      hexArray.push("0x" + value.toString(16).padStart(2, "0"));
    }

    const hexString = hexArray.join(", ");
    const line = `  ${hexString}`;
    lines.push(line);
  }

  return lines.join(",\n");
}

function inlineFile(srcFilePath: string, opts?: any): Promise<string> {
  console.debug("Inlining file: ", srcFilePath);
  return new Promise((resolve, reject) => {
    new Inliner(srcFilePath, opts, function (err: Error, result: string) {
      console.log("inlineFile result: ", result);
      if (err) {
        return reject(err);
      }
      resolve(result);
    });
  });
}

function gzipFile(input: Buffer | string): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    zlib.gzip(
      input,
      { level: zlib.constants.Z_BEST_COMPRESSION },
      (error, result) => {
        if (error) {
          return reject(error);
        }
        console.log("gzipped: ", result);
        resolve(result);
      }
    );
  });
}

async function specToChunk(s: Spec) {
  const { inline, method, gzip, filePath, name, prepend, append } = s;
  let buf: Buffer | string;

  if (inline) {
    // inline/gzip
    buf = await inlineFile(filePath);
  }
  if (!buf) {
    buf = await readFile(filePath);
  }
  if (gzip) {
    buf = await gzipFile(buf);
  }

  let chunk = `// Autogenerated from ${relPath(
    pathResolve(__dirname, "../src"),
    filePath
  )}, do not edit!!`;
  if (method == "plaintext") {
    buf = typeof buf === "string" ? buf : buf.toString("utf-8");
    chunk += `
 const char ${name}[] PROGMEM = R"${prepend || ""}${buf}${append || ""}";
 
 `;
  } else if (method == "binary") {
    buf = typeof buf === "string" ? Buffer.from(buf) : buf;
    const result = hexdump(buf);
    chunk += `
 const ${result.length > UINT16_MAX ? "uint32_t" : "uint16_t"} ${name}_L = ${
      result.length
    };
 const uint8_t ${name}[] PROGMEM = {
 ${result}
 };
 
 `;
  } else {
    console.warn("Unknown method: " + method);
    return undefined;
  }

  return s.mangle ? s.mangle(chunk) : chunk;
}

async function writeChunks(specs: Spec[], outFile: string) {
  const ps = specs.map(async (s) => {
    const { filePath, name } = s;
    console.debug(`[scripts/build.html] Reading ${filePath} as ${name}`);
    return specToChunk(s).catch((error) => {
      throw {
        name,
        filePath,
        error,
      };
    });
  });

  const results = await Promise.allSettled(ps);
  const output = results
    .map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      }

      const { name, filePath, error } = result.reason;
      console.error(
        `[scripts/build.html] Failed to build ${name} from ${filePath}`,
        error
      );
      return "";
    })
    .join("");

  console.info(
    `[scripts/build.html] Writing ${output.length} characters into ${outFile}`
  );

  await writeFile(outFile, output);
}

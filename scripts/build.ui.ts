/**
 * Script to build, inline, gzip UI source.
 */

// eslint-disable-next-line @typescript-eslint/no-var-requires
const Inliner = require("inliner");
import { writeFile, readFile } from "fs/promises";
import { resolve as pathResolve, relative as relPath } from "path";
import * as zlib from "zlib";

const UINT16_MAX = 65535;

const log = (...msgs: any[]) => {
  console.log("[build.ui]", ...msgs);
};
const warn = (...msgs: any[]) => {
  console.warn("[build.ui]", ...msgs);
};

interface Spec {
  name: string;
  filePath: string;
  method: "plaintext" | "binary";
  append?: string;
  prepend?: string;
  mangle?: (chunk: string) => string;
  inline?: boolean;
  gzip?: boolean;
}

writeChunks(
  [
    {
      filePath: pathResolve(__dirname, "../public/index.html"),
      name: "PAGE_index",
      prepend: "=====(",
      append: ")=====",
      method: "binary",
      inline: true,
      gzip: true,
    },
  ],
  "src/ui_index.h"
);

// TODO: Add favicon
writeChunks(
  [
    {
      filePath: pathResolve(__dirname, "../public/bg.jpg"),
      name: "IMG_background",
      prepend: "=====(",
      append: ")=====",
      method: "binary",
      inline: false,
      gzip: true,
    },
  ],
  "src/ui_fixtures.h"
);

function hexDump(buffer: Buffer): string {
  return [...new Uint8Array(buffer)]
    .map((x) => "0x" + x.toString(16).padStart(2, "0"))
    .join(",");
}

function inlineFile(srcFilePath: string, opts?: any): Promise<string> {
  log("Inlining file: ", srcFilePath);
  return new Promise((resolve, reject) => {
    new Inliner(srcFilePath, opts, function (err: Error, result: string) {
      if (err) {
        return reject(err);
      }
      resolve(result);
    });
  });
}

function gzipFile(input: Buffer | string): Promise<Buffer> {
  log("Full size: ", input.length);
  return new Promise((resolve, reject) => {
    zlib.gzip(
      input,
      { level: zlib.constants.Z_BEST_COMPRESSION },
      (error, result) => {
        if (error) {
          return reject(error);
        }
        log("Gzipped size: ", result.length);
        resolve(result);
      }
    );
  });
}

async function specToChunk(s: Spec) {
  const { inline, method, gzip, filePath, name, prepend, append } = s;
  let buf: Buffer | string;

  if (inline) {
    // inline/gzip
    buf = await inlineFile(filePath);
  }
  if (!buf) {
    buf = await readFile(filePath);
  }
  if (gzip) {
    buf = await gzipFile(buf);
  }

  let chunk = `// Autogenerated from ${relPath(
    pathResolve(__dirname, "../src"),
    filePath
  )}, do not edit!!`;
  if (method == "plaintext") {
    buf = typeof buf === "string" ? buf : buf.toString("utf-8");
    chunk += `
 const uint8_t ${name}[] PROGMEM = R"${prepend || ""}${buf}${append || ""}";
 
 `;
  } else if (method == "binary") {
    buf = typeof buf === "string" ? Buffer.from(buf) : buf;
    const result = hexDump(buf);
    chunk += `
 const ${result.length > UINT16_MAX ? "uint32_t" : "uint16_t"} ${name}_L = ${
      buf.length
    };
 const uint8_t ${name}[] PROGMEM = {
 ${result}
 };
 
 `;
  } else {
    warn("Unknown method: " + method);
    return undefined;
  }

  return s.mangle ? s.mangle(chunk) : chunk;
}

async function writeChunks(specs: Spec[], outFile: string) {
  const ps = specs.map(async (s) => {
    const { filePath, name } = s;
    log(`Reading ${filePath} as ${name}`);
    return specToChunk(s).catch((error) => {
      throw {
        name,
        filePath,
        error,
      };
    });
  });

  const results = await Promise.allSettled(ps);
  const output = results
    .map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      }

      const { name, filePath, error } = result.reason;
      warn(`Failed to build ${name} from ${filePath}`, error);
      return "";
    })
    .join("");

  log(`Writing ${output.length} characters into ${outFile}`);
  await writeFile(outFile, output);
}
